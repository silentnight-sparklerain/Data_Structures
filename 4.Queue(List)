//队列——链表实现
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

typedef int ElementType;

//定义结点结构体
typedef struct Node* QueueNode;
struct Node
{
	ElementType data;
	QueueNode Next;
};

//定义队列结构体
typedef struct linked* LinkedQueue;
struct linked
{
	QueueNode front;  //队头指针
	QueueNode rear;  //队尾指针
	int size;  //队列大小
};


//队列函数声明
LinkedQueue createQueue();  //创建一个队列
bool IsEmpty(LinkedQueue queue);  //判断队列是否为空
int sizeQueue(LinkedQueue queue);  //获取队列大小
void EnQueue(LinkedQueue queue, ElementType X);  //入队
ElementType DeQueue(LinkedQueue queue);  //出队
ElementType HeadQueue(LinkedQueue queue);  //获取队头元素
void PrintQueue(LinkedQueue queue);  //打印队列
void clearQueue(LinkedQueue queue);  //清空队列


//创建一个队列
LinkedQueue createQueue()
{
	LinkedQueue queue = (LinkedQueue)malloc(sizeof(LinkedQueue));
	if (queue == NULL)
	{
		printf("申请队列失败！\n");
		return NULL;
	}
	queue->front = NULL;
	queue->rear = NULL;
	queue->size = 0;
	return queue;
}

//判断队列是否为空
bool IsEmpty(LinkedQueue queue)
{
	return queue->front == NULL;
}

//获取队列大小
int sizeQueue(LinkedQueue queue)
{
	return queue->size;
}

//入队
void EnQueue(LinkedQueue queue, ElementType X)
{
	QueueNode newnode = (QueueNode)malloc(sizeof(struct Node));
	if (newnode == NULL)
	{
		printf("申请结点失败！\n");
		return;
	}
	newnode->data = X;
	newnode->Next = NULL;
	if (IsEmpty(queue))
	{
		queue->front = newnode;
		queue->rear = newnode;
	}
	else
	{
		queue->rear->Next = newnode;
		queue->rear = newnode;
	}
	queue->size++;
}

//出队
ElementType DeQueue(LinkedQueue queue)
{
	if (IsEmpty(queue))
	{
		printf("队已空，无法出队！\n");
		return 0;
	}
	QueueNode current = queue->front;
	ElementType X = current->data;
	queue->front = current->Next;
	if (queue->front == NULL)
	{
		queue->rear = NULL;
	}
	free(current);
	current = NULL;
	queue->size--;
	return X;
}

//获取队头元素
ElementType HeadQueue(LinkedQueue queue)
{
	if (IsEmpty(queue))
	{
		printf("队已空，无法获取队头元素！\n");
		return 0;
	}
	return queue->front->data;
}

//打印队列
void PrintQueue(LinkedQueue queue)
{
	if (IsEmpty(queue))
	{
		printf("队已空！\n");
		return;
	}
	QueueNode current = queue->front;
	printf("队列内容：（从头到尾）");
	while (current != NULL)
	{
		printf("%d ", current->data);
		current = current->Next;
	}
	printf("\n");
}

//清空队列
void clearQueue(LinkedQueue queue)
{
	while (!IsEmpty(queue))
	{
		DeQueue(queue);
	}
}

// 测试函数
void test() 
{
	LinkedQueue queue = createQueue();
	if (queue == NULL) 
	{
		printf("创建队列失败！\n");
		return -1;
	}
	printf("队列创建成功。\n");

	// 测试空队列操作
	printf("\n1. 测试空队列:\n");
	printf("队列是否为空: %s\n", IsEmpty(queue) ? "是" : "否");
	printf("队列大小: %d\n", sizeQueue(queue));
	printf("尝试获取队头元素: ");
	ElementType head = HeadQueue(queue); // 应打印错误信息
	printf("尝试出队: ");
	ElementType deq = DeQueue(queue);    // 应打印错误信息

	// 测试入队操作
	printf("\n2. 测试入队操作:\n");
	EnQueue(queue, 10);
	EnQueue(queue, 20);
	EnQueue(queue, 30);
	printf("入队 10, 20, 30 后队列大小: %d\n", sizeQueue(queue));
	PrintQueue(queue); // 应输出: 10 20 30

	// 测试获取队头元素
	printf("\n3. 测试获取队头元素:\n");
	head = HeadQueue(queue);
	printf("队头元素: %d\n", head);

	// 测试出队操作
	printf("\n4. 测试出队操作:\n");
	deq = DeQueue(queue);
	printf("出队元素: %d\n", deq);
	printf("出队后队列大小: %d\n", sizeQueue(queue));
	PrintQueue(queue); // 应输出: 20 30

	// 再次入队和出队测试
	printf("\n5. 再次入队和出队测试:\n");
	EnQueue(queue, 40);
	printf("入队 40 后:\n");
	PrintQueue(queue); // 应输出: 20 30 40

	deq = DeQueue(queue);
	printf("出队元素: %d\n", deq);
	deq = DeQueue(queue);
	printf("出队元素: %d\n", deq);
	printf("两次出队后队列大小: %d\n", sizeQueue(queue));
	PrintQueue(queue); // 应输出: 40

	// 测试清空队列
	printf("\n6. 测试清空队列:\n");
	clearQueue(queue);
	printf("清空后队列大小: %d\n", sizeQueue(queue));
	printf("队列是否为空: %s\n", IsEmpty(queue) ? "是" : "否");

	// 测试边界情况：清空后再次操作
	printf("\n7. 测试边界情况（清空后操作）:\n");
	printf("尝试获取队头元素: ");
	head = HeadQueue(queue); // 应打印错误信息
	printf("尝试出队: ");
	deq = DeQueue(queue);    // 应打印错误信息

	// 重新入队测试队列是否正常工作
	printf("\n8. 重新入队测试:\n");
	EnQueue(queue, 50);
	EnQueue(queue, 60);
	printf("重新入队 50, 60 后队列大小: %d\n", sizeQueue(queue));
	PrintQueue(queue); // 应输出: 50 60

	// 释放队列内存
	printf("\n9. 释放队列内存:\n");
	clearQueue(queue); // 清空队列释放所有节点
	printf("队列内存已释放。\n");
}

int main()
{
	test();
	return 0;
}
